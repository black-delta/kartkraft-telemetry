// automatically generated by the FlatBuffers compiler, do not modify


#![allow(dead_code)]
#![allow(unused_imports)]
extern crate flatbuffers;

pub mod kart_kraft {
  #![allow(dead_code)]
  #![allow(unused_imports)]

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;

/// State of vehicle
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum VehicleState {
  Idle = 0,
  Pits = 1,
  PitGrid = 2,
  Outlap = 3,
  RollingStart = 4,
  FlyingStart = 5,
  StartGrid = 6,
  Racing = 7,
  Retired = 8,
  Finished = 9,

}

const ENUM_MIN_VEHICLE_STATE: u8 = 0;
const ENUM_MAX_VEHICLE_STATE: u8 = 9;

impl<'a> flatbuffers::Follow<'a> for VehicleState {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for VehicleState {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const VehicleState;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const VehicleState;
    unsafe { *p }
  }
}

impl flatbuffers::Push for VehicleState {
    type Output = VehicleState;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<VehicleState>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_VEHICLE_STATE:[VehicleState; 10] = [
  VehicleState::Idle,
  VehicleState::Pits,
  VehicleState::PitGrid,
  VehicleState::Outlap,
  VehicleState::RollingStart,
  VehicleState::FlyingStart,
  VehicleState::StartGrid,
  VehicleState::Racing,
  VehicleState::Retired,
  VehicleState::Finished
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_VEHICLE_STATE:[&'static str; 10] = [
    "Idle",
    "Pits",
    "PitGrid",
    "Outlap",
    "RollingStart",
    "FlyingStart",
    "StartGrid",
    "Racing",
    "Retired",
    "Finished"
];

pub fn enum_name_vehicle_state(e: VehicleState) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_VEHICLE_STATE[index]
}

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum Surface {
  None = 0,
  Asphalt = 1,
  Grass = 2,
  Gravel = 3,
  Kerb = 4,
  Sand = 5,
  Tyre = 6,

}

const ENUM_MIN_SURFACE: u8 = 0;
const ENUM_MAX_SURFACE: u8 = 6;

impl<'a> flatbuffers::Follow<'a> for Surface {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for Surface {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const Surface;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const Surface;
    unsafe { *p }
  }
}

impl flatbuffers::Push for Surface {
    type Output = Surface;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Surface>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_SURFACE:[Surface; 7] = [
  Surface::None,
  Surface::Asphalt,
  Surface::Grass,
  Surface::Gravel,
  Surface::Kerb,
  Surface::Sand,
  Surface::Tyre
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_SURFACE:[&'static str; 7] = [
    "None",
    "Asphalt",
    "Grass",
    "Gravel",
    "Kerb",
    "Sand",
    "Tyre"
];

pub fn enum_name_surface(e: Surface) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_SURFACE[index]
}

/// Useful generic color struct 
// struct Color, aligned to 1
#[repr(C, align(1))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Color {
  r_: i8,
  g_: i8,
  b_: i8,
} // pub struct Color
impl flatbuffers::SafeSliceAccess for Color {}
impl<'a> flatbuffers::Follow<'a> for Color {
  type Inner = &'a Color;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Color>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Color {
  type Inner = &'a Color;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Color>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Color {
    type Output = Color;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Color as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Color {
    type Output = Color;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Color as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}


impl Color {
  pub fn new<'a>(_r: i8, _g: i8, _b: i8) -> Self {
    Color {
      r_: _r.to_little_endian(),
      g_: _g.to_little_endian(),
      b_: _b.to_little_endian(),

    }
  }
  pub fn r<'a>(&'a self) -> i8 {
    self.r_.from_little_endian()
  }
  pub fn g<'a>(&'a self) -> i8 {
    self.g_.from_little_endian()
  }
  pub fn b<'a>(&'a self) -> i8 {
    self.b_.from_little_endian()
  }
}

pub enum WheelOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Wheel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Wheel<'a> {
    type Inner = Wheel<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Wheel<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Wheel {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args WheelArgs) -> flatbuffers::WIPOffset<Wheel<'bldr>> {
      let mut builder = WheelBuilder::new(_fbb);
      builder.add_slipAngle(args.slipAngle);
      builder.add_surface(args.surface);
      builder.finish()
    }

    pub const VT_SURFACE: flatbuffers::VOffsetT = 4;
    pub const VT_SLIPANGLE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn surface(&self) -> Surface {
    self._tab.get::<Surface>(Wheel::VT_SURFACE, Some(Surface::None)).unwrap()
  }
  #[inline]
  pub fn slipAngle(&self) -> f32 {
    self._tab.get::<f32>(Wheel::VT_SLIPANGLE, Some(0.0)).unwrap()
  }
}

pub struct WheelArgs {
    pub surface: Surface,
    pub slipAngle: f32,
}
impl<'a> Default for WheelArgs {
    #[inline]
    fn default() -> Self {
        WheelArgs {
            surface: Surface::None,
            slipAngle: 0.0,
        }
    }
}
pub struct WheelBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WheelBuilder<'a, 'b> {
  #[inline]
  pub fn add_surface(&mut self, surface: Surface) {
    self.fbb_.push_slot::<Surface>(Wheel::VT_SURFACE, surface, Surface::None);
  }
  #[inline]
  pub fn add_slipAngle(&mut self, slipAngle: f32) {
    self.fbb_.push_slot::<f32>(Wheel::VT_SLIPANGLE, slipAngle, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WheelBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WheelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Wheel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

/// Motion data of local player for driving hardware motion simulators
pub enum MotionOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Motion<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Motion<'a> {
    type Inner = Motion<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Motion<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Motion {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MotionArgs<'args>) -> flatbuffers::WIPOffset<Motion<'bldr>> {
      let mut builder = MotionBuilder::new(_fbb);
      builder.add_worldVelocityZ(args.worldVelocityZ);
      builder.add_worldVelocityY(args.worldVelocityY);
      builder.add_worldVelocityX(args.worldVelocityX);
      if let Some(x) = args.wheels { builder.add_wheels(x); }
      builder.add_angularVelocityZ(args.angularVelocityZ);
      builder.add_angularVelocityY(args.angularVelocityY);
      builder.add_angularVelocityX(args.angularVelocityX);
      builder.add_velocityZ(args.velocityZ);
      builder.add_velocityY(args.velocityY);
      builder.add_velocityX(args.velocityX);
      builder.add_tractionLoss(args.tractionLoss);
      builder.add_accelerationZ(args.accelerationZ);
      builder.add_accelerationY(args.accelerationY);
      builder.add_accelerationX(args.accelerationX);
      builder.add_yaw(args.yaw);
      builder.add_roll(args.roll);
      builder.add_pitch(args.pitch);
      builder.finish()
    }

    pub const VT_PITCH: flatbuffers::VOffsetT = 4;
    pub const VT_ROLL: flatbuffers::VOffsetT = 6;
    pub const VT_YAW: flatbuffers::VOffsetT = 8;
    pub const VT_ACCELERATIONX: flatbuffers::VOffsetT = 10;
    pub const VT_ACCELERATIONY: flatbuffers::VOffsetT = 12;
    pub const VT_ACCELERATIONZ: flatbuffers::VOffsetT = 14;
    pub const VT_TRACTIONLOSS: flatbuffers::VOffsetT = 16;
    pub const VT_VELOCITYX: flatbuffers::VOffsetT = 18;
    pub const VT_VELOCITYY: flatbuffers::VOffsetT = 20;
    pub const VT_VELOCITYZ: flatbuffers::VOffsetT = 22;
    pub const VT_ANGULARVELOCITYX: flatbuffers::VOffsetT = 24;
    pub const VT_ANGULARVELOCITYY: flatbuffers::VOffsetT = 26;
    pub const VT_ANGULARVELOCITYZ: flatbuffers::VOffsetT = 28;
    pub const VT_WHEELS: flatbuffers::VOffsetT = 30;
    pub const VT_WORLDVELOCITYX: flatbuffers::VOffsetT = 32;
    pub const VT_WORLDVELOCITYY: flatbuffers::VOffsetT = 34;
    pub const VT_WORLDVELOCITYZ: flatbuffers::VOffsetT = 36;

  #[inline]
  pub fn pitch(&self) -> f32 {
    self._tab.get::<f32>(Motion::VT_PITCH, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn roll(&self) -> f32 {
    self._tab.get::<f32>(Motion::VT_ROLL, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn yaw(&self) -> f32 {
    self._tab.get::<f32>(Motion::VT_YAW, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn accelerationX(&self) -> f32 {
    self._tab.get::<f32>(Motion::VT_ACCELERATIONX, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn accelerationY(&self) -> f32 {
    self._tab.get::<f32>(Motion::VT_ACCELERATIONY, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn accelerationZ(&self) -> f32 {
    self._tab.get::<f32>(Motion::VT_ACCELERATIONZ, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn tractionLoss(&self) -> f32 {
    self._tab.get::<f32>(Motion::VT_TRACTIONLOSS, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn velocityX(&self) -> f32 {
    self._tab.get::<f32>(Motion::VT_VELOCITYX, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn velocityY(&self) -> f32 {
    self._tab.get::<f32>(Motion::VT_VELOCITYY, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn velocityZ(&self) -> f32 {
    self._tab.get::<f32>(Motion::VT_VELOCITYZ, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn angularVelocityX(&self) -> f32 {
    self._tab.get::<f32>(Motion::VT_ANGULARVELOCITYX, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn angularVelocityY(&self) -> f32 {
    self._tab.get::<f32>(Motion::VT_ANGULARVELOCITYY, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn angularVelocityZ(&self) -> f32 {
    self._tab.get::<f32>(Motion::VT_ANGULARVELOCITYZ, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn wheels(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Wheel<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Wheel<'a>>>>>(Motion::VT_WHEELS, None)
  }
  #[inline]
  pub fn worldVelocityX(&self) -> f32 {
    self._tab.get::<f32>(Motion::VT_WORLDVELOCITYX, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn worldVelocityY(&self) -> f32 {
    self._tab.get::<f32>(Motion::VT_WORLDVELOCITYY, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn worldVelocityZ(&self) -> f32 {
    self._tab.get::<f32>(Motion::VT_WORLDVELOCITYZ, Some(0.0)).unwrap()
  }
}

pub struct MotionArgs<'a> {
    pub pitch: f32,
    pub roll: f32,
    pub yaw: f32,
    pub accelerationX: f32,
    pub accelerationY: f32,
    pub accelerationZ: f32,
    pub tractionLoss: f32,
    pub velocityX: f32,
    pub velocityY: f32,
    pub velocityZ: f32,
    pub angularVelocityX: f32,
    pub angularVelocityY: f32,
    pub angularVelocityZ: f32,
    pub wheels: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Wheel<'a >>>>>,
    pub worldVelocityX: f32,
    pub worldVelocityY: f32,
    pub worldVelocityZ: f32,
}
impl<'a> Default for MotionArgs<'a> {
    #[inline]
    fn default() -> Self {
        MotionArgs {
            pitch: 0.0,
            roll: 0.0,
            yaw: 0.0,
            accelerationX: 0.0,
            accelerationY: 0.0,
            accelerationZ: 0.0,
            tractionLoss: 0.0,
            velocityX: 0.0,
            velocityY: 0.0,
            velocityZ: 0.0,
            angularVelocityX: 0.0,
            angularVelocityY: 0.0,
            angularVelocityZ: 0.0,
            wheels: None,
            worldVelocityX: 0.0,
            worldVelocityY: 0.0,
            worldVelocityZ: 0.0,
        }
    }
}
pub struct MotionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MotionBuilder<'a, 'b> {
  #[inline]
  pub fn add_pitch(&mut self, pitch: f32) {
    self.fbb_.push_slot::<f32>(Motion::VT_PITCH, pitch, 0.0);
  }
  #[inline]
  pub fn add_roll(&mut self, roll: f32) {
    self.fbb_.push_slot::<f32>(Motion::VT_ROLL, roll, 0.0);
  }
  #[inline]
  pub fn add_yaw(&mut self, yaw: f32) {
    self.fbb_.push_slot::<f32>(Motion::VT_YAW, yaw, 0.0);
  }
  #[inline]
  pub fn add_accelerationX(&mut self, accelerationX: f32) {
    self.fbb_.push_slot::<f32>(Motion::VT_ACCELERATIONX, accelerationX, 0.0);
  }
  #[inline]
  pub fn add_accelerationY(&mut self, accelerationY: f32) {
    self.fbb_.push_slot::<f32>(Motion::VT_ACCELERATIONY, accelerationY, 0.0);
  }
  #[inline]
  pub fn add_accelerationZ(&mut self, accelerationZ: f32) {
    self.fbb_.push_slot::<f32>(Motion::VT_ACCELERATIONZ, accelerationZ, 0.0);
  }
  #[inline]
  pub fn add_tractionLoss(&mut self, tractionLoss: f32) {
    self.fbb_.push_slot::<f32>(Motion::VT_TRACTIONLOSS, tractionLoss, 0.0);
  }
  #[inline]
  pub fn add_velocityX(&mut self, velocityX: f32) {
    self.fbb_.push_slot::<f32>(Motion::VT_VELOCITYX, velocityX, 0.0);
  }
  #[inline]
  pub fn add_velocityY(&mut self, velocityY: f32) {
    self.fbb_.push_slot::<f32>(Motion::VT_VELOCITYY, velocityY, 0.0);
  }
  #[inline]
  pub fn add_velocityZ(&mut self, velocityZ: f32) {
    self.fbb_.push_slot::<f32>(Motion::VT_VELOCITYZ, velocityZ, 0.0);
  }
  #[inline]
  pub fn add_angularVelocityX(&mut self, angularVelocityX: f32) {
    self.fbb_.push_slot::<f32>(Motion::VT_ANGULARVELOCITYX, angularVelocityX, 0.0);
  }
  #[inline]
  pub fn add_angularVelocityY(&mut self, angularVelocityY: f32) {
    self.fbb_.push_slot::<f32>(Motion::VT_ANGULARVELOCITYY, angularVelocityY, 0.0);
  }
  #[inline]
  pub fn add_angularVelocityZ(&mut self, angularVelocityZ: f32) {
    self.fbb_.push_slot::<f32>(Motion::VT_ANGULARVELOCITYZ, angularVelocityZ, 0.0);
  }
  #[inline]
  pub fn add_wheels(&mut self, wheels: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Wheel<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Motion::VT_WHEELS, wheels);
  }
  #[inline]
  pub fn add_worldVelocityX(&mut self, worldVelocityX: f32) {
    self.fbb_.push_slot::<f32>(Motion::VT_WORLDVELOCITYX, worldVelocityX, 0.0);
  }
  #[inline]
  pub fn add_worldVelocityY(&mut self, worldVelocityY: f32) {
    self.fbb_.push_slot::<f32>(Motion::VT_WORLDVELOCITYY, worldVelocityY, 0.0);
  }
  #[inline]
  pub fn add_worldVelocityZ(&mut self, worldVelocityZ: f32) {
    self.fbb_.push_slot::<f32>(Motion::VT_WORLDVELOCITYZ, worldVelocityZ, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MotionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MotionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Motion<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

/// Dash data for displaying state of current local/followed player
pub enum DashboardOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Dashboard<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Dashboard<'a> {
    type Inner = Dashboard<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Dashboard<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Dashboard {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DashboardArgs) -> flatbuffers::WIPOffset<Dashboard<'bldr>> {
      let mut builder = DashboardBuilder::new(_fbb);
      builder.add_lastLap(args.lastLap);
      builder.add_currentLap(args.currentLap);
      builder.add_bestLap(args.bestLap);
      builder.add_brake(args.brake);
      builder.add_throttle(args.throttle);
      builder.add_steer(args.steer);
      builder.add_rpm(args.rpm);
      builder.add_speed(args.speed);
      builder.add_sectorCount(args.sectorCount);
      builder.add_lapCount(args.lapCount);
      builder.add_pos(args.pos);
      builder.add_gear(args.gear);
      builder.finish()
    }

    pub const VT_SPEED: flatbuffers::VOffsetT = 4;
    pub const VT_RPM: flatbuffers::VOffsetT = 6;
    pub const VT_STEER: flatbuffers::VOffsetT = 8;
    pub const VT_THROTTLE: flatbuffers::VOffsetT = 10;
    pub const VT_BRAKE: flatbuffers::VOffsetT = 12;
    pub const VT_GEAR: flatbuffers::VOffsetT = 14;
    pub const VT_POS: flatbuffers::VOffsetT = 16;
    pub const VT_BESTLAP: flatbuffers::VOffsetT = 18;
    pub const VT_CURRENTLAP: flatbuffers::VOffsetT = 20;
    pub const VT_LASTLAP: flatbuffers::VOffsetT = 22;
    pub const VT_LAPCOUNT: flatbuffers::VOffsetT = 24;
    pub const VT_SECTORCOUNT: flatbuffers::VOffsetT = 26;

  #[inline]
  pub fn speed(&self) -> f32 {
    self._tab.get::<f32>(Dashboard::VT_SPEED, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn rpm(&self) -> f32 {
    self._tab.get::<f32>(Dashboard::VT_RPM, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn steer(&self) -> f32 {
    self._tab.get::<f32>(Dashboard::VT_STEER, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn throttle(&self) -> f32 {
    self._tab.get::<f32>(Dashboard::VT_THROTTLE, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn brake(&self) -> f32 {
    self._tab.get::<f32>(Dashboard::VT_BRAKE, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn gear(&self) -> i8 {
    self._tab.get::<i8>(Dashboard::VT_GEAR, Some(0)).unwrap()
  }
  #[inline]
  pub fn pos(&self) -> i8 {
    self._tab.get::<i8>(Dashboard::VT_POS, Some(0)).unwrap()
  }
  #[inline]
  pub fn bestLap(&self) -> f32 {
    self._tab.get::<f32>(Dashboard::VT_BESTLAP, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn currentLap(&self) -> f32 {
    self._tab.get::<f32>(Dashboard::VT_CURRENTLAP, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn lastLap(&self) -> f32 {
    self._tab.get::<f32>(Dashboard::VT_LASTLAP, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn lapCount(&self) -> u16 {
    self._tab.get::<u16>(Dashboard::VT_LAPCOUNT, Some(0)).unwrap()
  }
  #[inline]
  pub fn sectorCount(&self) -> u16 {
    self._tab.get::<u16>(Dashboard::VT_SECTORCOUNT, Some(0)).unwrap()
  }
}

pub struct DashboardArgs {
    pub speed: f32,
    pub rpm: f32,
    pub steer: f32,
    pub throttle: f32,
    pub brake: f32,
    pub gear: i8,
    pub pos: i8,
    pub bestLap: f32,
    pub currentLap: f32,
    pub lastLap: f32,
    pub lapCount: u16,
    pub sectorCount: u16,
}
impl<'a> Default for DashboardArgs {
    #[inline]
    fn default() -> Self {
        DashboardArgs {
            speed: 0.0,
            rpm: 0.0,
            steer: 0.0,
            throttle: 0.0,
            brake: 0.0,
            gear: 0,
            pos: 0,
            bestLap: 0.0,
            currentLap: 0.0,
            lastLap: 0.0,
            lapCount: 0,
            sectorCount: 0,
        }
    }
}
pub struct DashboardBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DashboardBuilder<'a, 'b> {
  #[inline]
  pub fn add_speed(&mut self, speed: f32) {
    self.fbb_.push_slot::<f32>(Dashboard::VT_SPEED, speed, 0.0);
  }
  #[inline]
  pub fn add_rpm(&mut self, rpm: f32) {
    self.fbb_.push_slot::<f32>(Dashboard::VT_RPM, rpm, 0.0);
  }
  #[inline]
  pub fn add_steer(&mut self, steer: f32) {
    self.fbb_.push_slot::<f32>(Dashboard::VT_STEER, steer, 0.0);
  }
  #[inline]
  pub fn add_throttle(&mut self, throttle: f32) {
    self.fbb_.push_slot::<f32>(Dashboard::VT_THROTTLE, throttle, 0.0);
  }
  #[inline]
  pub fn add_brake(&mut self, brake: f32) {
    self.fbb_.push_slot::<f32>(Dashboard::VT_BRAKE, brake, 0.0);
  }
  #[inline]
  pub fn add_gear(&mut self, gear: i8) {
    self.fbb_.push_slot::<i8>(Dashboard::VT_GEAR, gear, 0);
  }
  #[inline]
  pub fn add_pos(&mut self, pos: i8) {
    self.fbb_.push_slot::<i8>(Dashboard::VT_POS, pos, 0);
  }
  #[inline]
  pub fn add_bestLap(&mut self, bestLap: f32) {
    self.fbb_.push_slot::<f32>(Dashboard::VT_BESTLAP, bestLap, 0.0);
  }
  #[inline]
  pub fn add_currentLap(&mut self, currentLap: f32) {
    self.fbb_.push_slot::<f32>(Dashboard::VT_CURRENTLAP, currentLap, 0.0);
  }
  #[inline]
  pub fn add_lastLap(&mut self, lastLap: f32) {
    self.fbb_.push_slot::<f32>(Dashboard::VT_LASTLAP, lastLap, 0.0);
  }
  #[inline]
  pub fn add_lapCount(&mut self, lapCount: u16) {
    self.fbb_.push_slot::<u16>(Dashboard::VT_LAPCOUNT, lapCount, 0);
  }
  #[inline]
  pub fn add_sectorCount(&mut self, sectorCount: u16) {
    self.fbb_.push_slot::<u16>(Dashboard::VT_SECTORCOUNT, sectorCount, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DashboardBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DashboardBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Dashboard<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

/// Basic vehicle data for live timing. e.g. trackmap
pub enum VehicleOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Vehicle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Vehicle<'a> {
    type Inner = Vehicle<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Vehicle<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Vehicle {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args VehicleArgs<'args>) -> flatbuffers::WIPOffset<Vehicle<'bldr>> {
      let mut builder = VehicleBuilder::new(_fbb);
      builder.add_normalisedTrackPos(args.normalisedTrackPos);
      if let Some(x) = args.color { builder.add_color(x); }
      builder.add_sessionPos(args.sessionPos);
      builder.add_yaw(args.yaw);
      builder.add_posZ(args.posZ);
      builder.add_posY(args.posY);
      builder.add_posX(args.posX);
      builder.add_state(args.state);
      builder.finish()
    }

    pub const VT_STATE: flatbuffers::VOffsetT = 4;
    pub const VT_POSX: flatbuffers::VOffsetT = 6;
    pub const VT_POSY: flatbuffers::VOffsetT = 8;
    pub const VT_POSZ: flatbuffers::VOffsetT = 10;
    pub const VT_YAW: flatbuffers::VOffsetT = 12;
    pub const VT_SESSIONPOS: flatbuffers::VOffsetT = 14;
    pub const VT_COLOR: flatbuffers::VOffsetT = 16;
    pub const VT_NORMALISEDTRACKPOS: flatbuffers::VOffsetT = 18;

  #[inline]
  pub fn state(&self) -> VehicleState {
    self._tab.get::<VehicleState>(Vehicle::VT_STATE, Some(VehicleState::Idle)).unwrap()
  }
  #[inline]
  pub fn posX(&self) -> f32 {
    self._tab.get::<f32>(Vehicle::VT_POSX, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn posY(&self) -> f32 {
    self._tab.get::<f32>(Vehicle::VT_POSY, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn posZ(&self) -> f32 {
    self._tab.get::<f32>(Vehicle::VT_POSZ, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn yaw(&self) -> f32 {
    self._tab.get::<f32>(Vehicle::VT_YAW, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn sessionPos(&self) -> i32 {
    self._tab.get::<i32>(Vehicle::VT_SESSIONPOS, Some(0)).unwrap()
  }
  #[inline]
  pub fn color(&self) -> Option<&'a Color> {
    self._tab.get::<Color>(Vehicle::VT_COLOR, None)
  }
  #[inline]
  pub fn normalisedTrackPos(&self) -> f32 {
    self._tab.get::<f32>(Vehicle::VT_NORMALISEDTRACKPOS, Some(0.0)).unwrap()
  }
}

pub struct VehicleArgs<'a> {
    pub state: VehicleState,
    pub posX: f32,
    pub posY: f32,
    pub posZ: f32,
    pub yaw: f32,
    pub sessionPos: i32,
    pub color: Option<&'a  Color>,
    pub normalisedTrackPos: f32,
}
impl<'a> Default for VehicleArgs<'a> {
    #[inline]
    fn default() -> Self {
        VehicleArgs {
            state: VehicleState::Idle,
            posX: 0.0,
            posY: 0.0,
            posZ: 0.0,
            yaw: 0.0,
            sessionPos: 0,
            color: None,
            normalisedTrackPos: 0.0,
        }
    }
}
pub struct VehicleBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> VehicleBuilder<'a, 'b> {
  #[inline]
  pub fn add_state(&mut self, state: VehicleState) {
    self.fbb_.push_slot::<VehicleState>(Vehicle::VT_STATE, state, VehicleState::Idle);
  }
  #[inline]
  pub fn add_posX(&mut self, posX: f32) {
    self.fbb_.push_slot::<f32>(Vehicle::VT_POSX, posX, 0.0);
  }
  #[inline]
  pub fn add_posY(&mut self, posY: f32) {
    self.fbb_.push_slot::<f32>(Vehicle::VT_POSY, posY, 0.0);
  }
  #[inline]
  pub fn add_posZ(&mut self, posZ: f32) {
    self.fbb_.push_slot::<f32>(Vehicle::VT_POSZ, posZ, 0.0);
  }
  #[inline]
  pub fn add_yaw(&mut self, yaw: f32) {
    self.fbb_.push_slot::<f32>(Vehicle::VT_YAW, yaw, 0.0);
  }
  #[inline]
  pub fn add_sessionPos(&mut self, sessionPos: i32) {
    self.fbb_.push_slot::<i32>(Vehicle::VT_SESSIONPOS, sessionPos, 0);
  }
  #[inline]
  pub fn add_color(&mut self, color: &'b  Color) {
    self.fbb_.push_slot_always::<&Color>(Vehicle::VT_COLOR, color);
  }
  #[inline]
  pub fn add_normalisedTrackPos(&mut self, normalisedTrackPos: f32) {
    self.fbb_.push_slot::<f32>(Vehicle::VT_NORMALISEDTRACKPOS, normalisedTrackPos, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> VehicleBuilder<'a, 'b> {
    let start = _fbb.start_table();
    VehicleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Vehicle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

/// Session data
pub enum SessionOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Session<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Session<'a> {
    type Inner = Session<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Session<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Session {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SessionArgs<'args>) -> flatbuffers::WIPOffset<Session<'bldr>> {
      let mut builder = SessionBuilder::new(_fbb);
      if let Some(x) = args.vehicles { builder.add_vehicles(x); }
      builder.add_totalLaps(args.totalLaps);
      builder.add_timeLeft(args.timeLeft);
      builder.add_totalTime(args.totalTime);
      builder.finish()
    }

    pub const VT_TOTALTIME: flatbuffers::VOffsetT = 4;
    pub const VT_TIMELEFT: flatbuffers::VOffsetT = 6;
    pub const VT_TOTALLAPS: flatbuffers::VOffsetT = 8;
    pub const VT_VEHICLES: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn totalTime(&self) -> i32 {
    self._tab.get::<i32>(Session::VT_TOTALTIME, Some(0)).unwrap()
  }
  #[inline]
  pub fn timeLeft(&self) -> i32 {
    self._tab.get::<i32>(Session::VT_TIMELEFT, Some(0)).unwrap()
  }
  #[inline]
  pub fn totalLaps(&self) -> i32 {
    self._tab.get::<i32>(Session::VT_TOTALLAPS, Some(0)).unwrap()
  }
  #[inline]
  pub fn vehicles(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Vehicle<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Vehicle<'a>>>>>(Session::VT_VEHICLES, None)
  }
}

pub struct SessionArgs<'a> {
    pub totalTime: i32,
    pub timeLeft: i32,
    pub totalLaps: i32,
    pub vehicles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Vehicle<'a >>>>>,
}
impl<'a> Default for SessionArgs<'a> {
    #[inline]
    fn default() -> Self {
        SessionArgs {
            totalTime: 0,
            timeLeft: 0,
            totalLaps: 0,
            vehicles: None,
        }
    }
}
pub struct SessionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SessionBuilder<'a, 'b> {
  #[inline]
  pub fn add_totalTime(&mut self, totalTime: i32) {
    self.fbb_.push_slot::<i32>(Session::VT_TOTALTIME, totalTime, 0);
  }
  #[inline]
  pub fn add_timeLeft(&mut self, timeLeft: i32) {
    self.fbb_.push_slot::<i32>(Session::VT_TIMELEFT, timeLeft, 0);
  }
  #[inline]
  pub fn add_totalLaps(&mut self, totalLaps: i32) {
    self.fbb_.push_slot::<i32>(Session::VT_TOTALLAPS, totalLaps, 0);
  }
  #[inline]
  pub fn add_vehicles(&mut self, vehicles: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Vehicle<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Session::VT_VEHICLES, vehicles);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SessionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SessionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Session<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

/// Data associated with a vehicle which doesn't change dynamically during a race. e.g. class, num gears, driver name etc
pub enum VehicleConfigOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct VehicleConfig<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for VehicleConfig<'a> {
    type Inner = VehicleConfig<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> VehicleConfig<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        VehicleConfig {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args VehicleConfigArgs) -> flatbuffers::WIPOffset<VehicleConfig<'bldr>> {
      let mut builder = VehicleConfigBuilder::new(_fbb);
      builder.add_rpmMax(args.rpmMax);
      builder.add_rpmLimit(args.rpmLimit);
      builder.add_gearMax(args.gearMax);
      builder.finish()
    }

    pub const VT_RPMLIMIT: flatbuffers::VOffsetT = 4;
    pub const VT_RPMMAX: flatbuffers::VOffsetT = 6;
    pub const VT_GEARMAX: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn rpmLimit(&self) -> f32 {
    self._tab.get::<f32>(VehicleConfig::VT_RPMLIMIT, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn rpmMax(&self) -> f32 {
    self._tab.get::<f32>(VehicleConfig::VT_RPMMAX, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn gearMax(&self) -> i8 {
    self._tab.get::<i8>(VehicleConfig::VT_GEARMAX, Some(0)).unwrap()
  }
}

pub struct VehicleConfigArgs {
    pub rpmLimit: f32,
    pub rpmMax: f32,
    pub gearMax: i8,
}
impl<'a> Default for VehicleConfigArgs {
    #[inline]
    fn default() -> Self {
        VehicleConfigArgs {
            rpmLimit: 0.0,
            rpmMax: 0.0,
            gearMax: 0,
        }
    }
}
pub struct VehicleConfigBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> VehicleConfigBuilder<'a, 'b> {
  #[inline]
  pub fn add_rpmLimit(&mut self, rpmLimit: f32) {
    self.fbb_.push_slot::<f32>(VehicleConfig::VT_RPMLIMIT, rpmLimit, 0.0);
  }
  #[inline]
  pub fn add_rpmMax(&mut self, rpmMax: f32) {
    self.fbb_.push_slot::<f32>(VehicleConfig::VT_RPMMAX, rpmMax, 0.0);
  }
  #[inline]
  pub fn add_gearMax(&mut self, gearMax: i8) {
    self.fbb_.push_slot::<i8>(VehicleConfig::VT_GEARMAX, gearMax, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> VehicleConfigBuilder<'a, 'b> {
    let start = _fbb.start_table();
    VehicleConfigBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<VehicleConfig<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum TrackConfigOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct TrackConfig<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TrackConfig<'a> {
    type Inner = TrackConfig<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> TrackConfig<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TrackConfig {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TrackConfigArgs<'args>) -> flatbuffers::WIPOffset<TrackConfig<'bldr>> {
      let mut builder = TrackConfigBuilder::new(_fbb);
      if let Some(x) = args.name { builder.add_name(x); }
      builder.add_numSectors(args.numSectors);
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_NUMSECTORS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackConfig::VT_NAME, None)
  }
  #[inline]
  pub fn numSectors(&self) -> u8 {
    self._tab.get::<u8>(TrackConfig::VT_NUMSECTORS, Some(0)).unwrap()
  }
}

pub struct TrackConfigArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub numSectors: u8,
}
impl<'a> Default for TrackConfigArgs<'a> {
    #[inline]
    fn default() -> Self {
        TrackConfigArgs {
            name: None,
            numSectors: 0,
        }
    }
}
pub struct TrackConfigBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TrackConfigBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackConfig::VT_NAME, name);
  }
  #[inline]
  pub fn add_numSectors(&mut self, numSectors: u8) {
    self.fbb_.push_slot::<u8>(TrackConfig::VT_NUMSECTORS, numSectors, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TrackConfigBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TrackConfigBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TrackConfig<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

/// Root object from which all data can be extracted. You must check if motion, dash etc exist before using as not every packet will include all data.
pub enum FrameOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Frame<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Frame<'a> {
    type Inner = Frame<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Frame<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Frame {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FrameArgs<'args>) -> flatbuffers::WIPOffset<Frame<'bldr>> {
      let mut builder = FrameBuilder::new(_fbb);
      if let Some(x) = args.trackConfig { builder.add_trackConfig(x); }
      if let Some(x) = args.vehicleConfig { builder.add_vehicleConfig(x); }
      if let Some(x) = args.session { builder.add_session(x); }
      if let Some(x) = args.dash { builder.add_dash(x); }
      if let Some(x) = args.motion { builder.add_motion(x); }
      builder.add_timestamp(args.timestamp);
      builder.finish()
    }

    pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 4;
    pub const VT_MOTION: flatbuffers::VOffsetT = 6;
    pub const VT_DASH: flatbuffers::VOffsetT = 8;
    pub const VT_SESSION: flatbuffers::VOffsetT = 10;
    pub const VT_VEHICLECONFIG: flatbuffers::VOffsetT = 12;
    pub const VT_TRACKCONFIG: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn timestamp(&self) -> f32 {
    self._tab.get::<f32>(Frame::VT_TIMESTAMP, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn motion(&self) -> Option<Motion<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Motion<'a>>>(Frame::VT_MOTION, None)
  }
  #[inline]
  pub fn dash(&self) -> Option<Dashboard<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Dashboard<'a>>>(Frame::VT_DASH, None)
  }
  #[inline]
  pub fn session(&self) -> Option<Session<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Session<'a>>>(Frame::VT_SESSION, None)
  }
  #[inline]
  pub fn vehicleConfig(&self) -> Option<VehicleConfig<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<VehicleConfig<'a>>>(Frame::VT_VEHICLECONFIG, None)
  }
  #[inline]
  pub fn trackConfig(&self) -> Option<TrackConfig<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<TrackConfig<'a>>>(Frame::VT_TRACKCONFIG, None)
  }
}

pub struct FrameArgs<'a> {
    pub timestamp: f32,
    pub motion: Option<flatbuffers::WIPOffset<Motion<'a >>>,
    pub dash: Option<flatbuffers::WIPOffset<Dashboard<'a >>>,
    pub session: Option<flatbuffers::WIPOffset<Session<'a >>>,
    pub vehicleConfig: Option<flatbuffers::WIPOffset<VehicleConfig<'a >>>,
    pub trackConfig: Option<flatbuffers::WIPOffset<TrackConfig<'a >>>,
}
impl<'a> Default for FrameArgs<'a> {
    #[inline]
    fn default() -> Self {
        FrameArgs {
            timestamp: 0.0,
            motion: None,
            dash: None,
            session: None,
            vehicleConfig: None,
            trackConfig: None,
        }
    }
}
pub struct FrameBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FrameBuilder<'a, 'b> {
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: f32) {
    self.fbb_.push_slot::<f32>(Frame::VT_TIMESTAMP, timestamp, 0.0);
  }
  #[inline]
  pub fn add_motion(&mut self, motion: flatbuffers::WIPOffset<Motion<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Motion>>(Frame::VT_MOTION, motion);
  }
  #[inline]
  pub fn add_dash(&mut self, dash: flatbuffers::WIPOffset<Dashboard<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Dashboard>>(Frame::VT_DASH, dash);
  }
  #[inline]
  pub fn add_session(&mut self, session: flatbuffers::WIPOffset<Session<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Session>>(Frame::VT_SESSION, session);
  }
  #[inline]
  pub fn add_vehicleConfig(&mut self, vehicleConfig: flatbuffers::WIPOffset<VehicleConfig<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<VehicleConfig>>(Frame::VT_VEHICLECONFIG, vehicleConfig);
  }
  #[inline]
  pub fn add_trackConfig(&mut self, trackConfig: flatbuffers::WIPOffset<TrackConfig<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TrackConfig>>(Frame::VT_TRACKCONFIG, trackConfig);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FrameBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FrameBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Frame<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

#[inline]
pub fn get_root_as_frame<'a>(buf: &'a [u8]) -> Frame<'a> {
  flatbuffers::get_root::<Frame<'a>>(buf)
}

#[inline]
pub fn get_size_prefixed_root_as_frame<'a>(buf: &'a [u8]) -> Frame<'a> {
  flatbuffers::get_size_prefixed_root::<Frame<'a>>(buf)
}

pub const FRAME_IDENTIFIER: &'static str = "KKFB";

#[inline]
pub fn frame_buffer_has_identifier(buf: &[u8]) -> bool {
  return flatbuffers::buffer_has_identifier(buf, FRAME_IDENTIFIER, false);
}

#[inline]
pub fn frame_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  return flatbuffers::buffer_has_identifier(buf, FRAME_IDENTIFIER, true);
}

#[inline]
pub fn finish_frame_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Frame<'a>>) {
  fbb.finish(root, Some(FRAME_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_frame_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Frame<'a>>) {
  fbb.finish_size_prefixed(root, Some(FRAME_IDENTIFIER));
}
}  // pub mod KartKraft


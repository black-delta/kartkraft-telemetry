// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FRAME_KARTKRAFT_H_
#define FLATBUFFERS_GENERATED_FRAME_KARTKRAFT_H_

#include "flatbuffers/flatbuffers.h"

namespace KartKraft {

struct Color;

struct Motion;

struct Dashboard;

struct Vehicle;

struct Session;

struct Frame;

enum VehicleState {
  VehicleState_Unknown = 0,
  VehicleState_Pits = 1,
  VehicleState_Outlap = 2,
  VehicleState_Racing = 3,
  VehicleState_Retired = 4,
  VehicleState_MIN = VehicleState_Unknown,
  VehicleState_MAX = VehicleState_Retired
};

inline const VehicleState (&EnumValuesVehicleState())[5] {
  static const VehicleState values[] = {
    VehicleState_Unknown,
    VehicleState_Pits,
    VehicleState_Outlap,
    VehicleState_Racing,
    VehicleState_Retired
  };
  return values;
}

inline const char * const *EnumNamesVehicleState() {
  static const char * const names[] = {
    "Unknown",
    "Pits",
    "Outlap",
    "Racing",
    "Retired",
    nullptr
  };
  return names;
}

inline const char *EnumNameVehicleState(VehicleState e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesVehicleState()[index];
}

/// Useful generic color struct 
FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Color FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t r_;
  int8_t g_;
  int8_t b_;

 public:
  Color() {
    memset(this, 0, sizeof(Color));
  }
  Color(int8_t _r, int8_t _g, int8_t _b)
      : r_(flatbuffers::EndianScalar(_r)),
        g_(flatbuffers::EndianScalar(_g)),
        b_(flatbuffers::EndianScalar(_b)) {
  }
  int8_t r() const {
    return flatbuffers::EndianScalar(r_);
  }
  int8_t g() const {
    return flatbuffers::EndianScalar(g_);
  }
  int8_t b() const {
    return flatbuffers::EndianScalar(b_);
  }
};
FLATBUFFERS_STRUCT_END(Color, 3);

/// Motion data of local player for driving hardware motion simulators
struct Motion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PITCH = 4,
    VT_ROLL = 6,
    VT_YAW = 8,
    VT_ACCELERATIONX = 10,
    VT_ACCELERATIONY = 12,
    VT_ACCELERATIONZ = 14,
    VT_TRACTION = 16
  };
  float pitch() const {
    return GetField<float>(VT_PITCH, 0.0f);
  }
  float roll() const {
    return GetField<float>(VT_ROLL, 0.0f);
  }
  float yaw() const {
    return GetField<float>(VT_YAW, 0.0f);
  }
  float accelerationX() const {
    return GetField<float>(VT_ACCELERATIONX, 0.0f);
  }
  float accelerationY() const {
    return GetField<float>(VT_ACCELERATIONY, 0.0f);
  }
  float accelerationZ() const {
    return GetField<float>(VT_ACCELERATIONZ, 0.0f);
  }
  float traction() const {
    return GetField<float>(VT_TRACTION, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_PITCH) &&
           VerifyField<float>(verifier, VT_ROLL) &&
           VerifyField<float>(verifier, VT_YAW) &&
           VerifyField<float>(verifier, VT_ACCELERATIONX) &&
           VerifyField<float>(verifier, VT_ACCELERATIONY) &&
           VerifyField<float>(verifier, VT_ACCELERATIONZ) &&
           VerifyField<float>(verifier, VT_TRACTION) &&
           verifier.EndTable();
  }
};

struct MotionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pitch(float pitch) {
    fbb_.AddElement<float>(Motion::VT_PITCH, pitch, 0.0f);
  }
  void add_roll(float roll) {
    fbb_.AddElement<float>(Motion::VT_ROLL, roll, 0.0f);
  }
  void add_yaw(float yaw) {
    fbb_.AddElement<float>(Motion::VT_YAW, yaw, 0.0f);
  }
  void add_accelerationX(float accelerationX) {
    fbb_.AddElement<float>(Motion::VT_ACCELERATIONX, accelerationX, 0.0f);
  }
  void add_accelerationY(float accelerationY) {
    fbb_.AddElement<float>(Motion::VT_ACCELERATIONY, accelerationY, 0.0f);
  }
  void add_accelerationZ(float accelerationZ) {
    fbb_.AddElement<float>(Motion::VT_ACCELERATIONZ, accelerationZ, 0.0f);
  }
  void add_traction(float traction) {
    fbb_.AddElement<float>(Motion::VT_TRACTION, traction, 0.0f);
  }
  explicit MotionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MotionBuilder &operator=(const MotionBuilder &);
  flatbuffers::Offset<Motion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Motion>(end);
    return o;
  }
};

inline flatbuffers::Offset<Motion> CreateMotion(
    flatbuffers::FlatBufferBuilder &_fbb,
    float pitch = 0.0f,
    float roll = 0.0f,
    float yaw = 0.0f,
    float accelerationX = 0.0f,
    float accelerationY = 0.0f,
    float accelerationZ = 0.0f,
    float traction = 0.0f) {
  MotionBuilder builder_(_fbb);
  builder_.add_traction(traction);
  builder_.add_accelerationZ(accelerationZ);
  builder_.add_accelerationY(accelerationY);
  builder_.add_accelerationX(accelerationX);
  builder_.add_yaw(yaw);
  builder_.add_roll(roll);
  builder_.add_pitch(pitch);
  return builder_.Finish();
}

/// Dash data for displaying state of current local/followed player
struct Dashboard FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SPEED = 4,
    VT_RPM = 6,
    VT_STEER = 8,
    VT_THROTTLE = 10,
    VT_BRAKE = 12,
    VT_GEAR = 14,
    VT_POS = 16,
    VT_BESTLAP = 18
  };
  float speed() const {
    return GetField<float>(VT_SPEED, 0.0f);
  }
  float rpm() const {
    return GetField<float>(VT_RPM, 0.0f);
  }
  float steer() const {
    return GetField<float>(VT_STEER, 0.0f);
  }
  float throttle() const {
    return GetField<float>(VT_THROTTLE, 0.0f);
  }
  float brake() const {
    return GetField<float>(VT_BRAKE, 0.0f);
  }
  int8_t gear() const {
    return GetField<int8_t>(VT_GEAR, 0);
  }
  int8_t pos() const {
    return GetField<int8_t>(VT_POS, 0);
  }
  float bestLap() const {
    return GetField<float>(VT_BESTLAP, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_SPEED) &&
           VerifyField<float>(verifier, VT_RPM) &&
           VerifyField<float>(verifier, VT_STEER) &&
           VerifyField<float>(verifier, VT_THROTTLE) &&
           VerifyField<float>(verifier, VT_BRAKE) &&
           VerifyField<int8_t>(verifier, VT_GEAR) &&
           VerifyField<int8_t>(verifier, VT_POS) &&
           VerifyField<float>(verifier, VT_BESTLAP) &&
           verifier.EndTable();
  }
};

struct DashboardBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_speed(float speed) {
    fbb_.AddElement<float>(Dashboard::VT_SPEED, speed, 0.0f);
  }
  void add_rpm(float rpm) {
    fbb_.AddElement<float>(Dashboard::VT_RPM, rpm, 0.0f);
  }
  void add_steer(float steer) {
    fbb_.AddElement<float>(Dashboard::VT_STEER, steer, 0.0f);
  }
  void add_throttle(float throttle) {
    fbb_.AddElement<float>(Dashboard::VT_THROTTLE, throttle, 0.0f);
  }
  void add_brake(float brake) {
    fbb_.AddElement<float>(Dashboard::VT_BRAKE, brake, 0.0f);
  }
  void add_gear(int8_t gear) {
    fbb_.AddElement<int8_t>(Dashboard::VT_GEAR, gear, 0);
  }
  void add_pos(int8_t pos) {
    fbb_.AddElement<int8_t>(Dashboard::VT_POS, pos, 0);
  }
  void add_bestLap(float bestLap) {
    fbb_.AddElement<float>(Dashboard::VT_BESTLAP, bestLap, 0.0f);
  }
  explicit DashboardBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DashboardBuilder &operator=(const DashboardBuilder &);
  flatbuffers::Offset<Dashboard> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Dashboard>(end);
    return o;
  }
};

inline flatbuffers::Offset<Dashboard> CreateDashboard(
    flatbuffers::FlatBufferBuilder &_fbb,
    float speed = 0.0f,
    float rpm = 0.0f,
    float steer = 0.0f,
    float throttle = 0.0f,
    float brake = 0.0f,
    int8_t gear = 0,
    int8_t pos = 0,
    float bestLap = 0.0f) {
  DashboardBuilder builder_(_fbb);
  builder_.add_bestLap(bestLap);
  builder_.add_brake(brake);
  builder_.add_throttle(throttle);
  builder_.add_steer(steer);
  builder_.add_rpm(rpm);
  builder_.add_speed(speed);
  builder_.add_pos(pos);
  builder_.add_gear(gear);
  return builder_.Finish();
}

/// Basic vehicle data for live timing. e.g. trackmap
struct Vehicle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STATE = 4,
    VT_POSX = 6,
    VT_POSY = 8,
    VT_POSZ = 10,
    VT_YAW = 12,
    VT_SESSIONPOS = 14,
    VT_COLOR = 16,
    VT_NORMALISEDTRACKPOS = 18
  };
  VehicleState state() const {
    return static_cast<VehicleState>(GetField<int8_t>(VT_STATE, 0));
  }
  float posX() const {
    return GetField<float>(VT_POSX, 0.0f);
  }
  float posY() const {
    return GetField<float>(VT_POSY, 0.0f);
  }
  float posZ() const {
    return GetField<float>(VT_POSZ, 0.0f);
  }
  float yaw() const {
    return GetField<float>(VT_YAW, 0.0f);
  }
  int32_t sessionPos() const {
    return GetField<int32_t>(VT_SESSIONPOS, 0);
  }
  const Color *color() const {
    return GetStruct<const Color *>(VT_COLOR);
  }
  float normalisedTrackPos() const {
    return GetField<float>(VT_NORMALISEDTRACKPOS, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_STATE) &&
           VerifyField<float>(verifier, VT_POSX) &&
           VerifyField<float>(verifier, VT_POSY) &&
           VerifyField<float>(verifier, VT_POSZ) &&
           VerifyField<float>(verifier, VT_YAW) &&
           VerifyField<int32_t>(verifier, VT_SESSIONPOS) &&
           VerifyField<Color>(verifier, VT_COLOR) &&
           VerifyField<float>(verifier, VT_NORMALISEDTRACKPOS) &&
           verifier.EndTable();
  }
};

struct VehicleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_state(VehicleState state) {
    fbb_.AddElement<int8_t>(Vehicle::VT_STATE, static_cast<int8_t>(state), 0);
  }
  void add_posX(float posX) {
    fbb_.AddElement<float>(Vehicle::VT_POSX, posX, 0.0f);
  }
  void add_posY(float posY) {
    fbb_.AddElement<float>(Vehicle::VT_POSY, posY, 0.0f);
  }
  void add_posZ(float posZ) {
    fbb_.AddElement<float>(Vehicle::VT_POSZ, posZ, 0.0f);
  }
  void add_yaw(float yaw) {
    fbb_.AddElement<float>(Vehicle::VT_YAW, yaw, 0.0f);
  }
  void add_sessionPos(int32_t sessionPos) {
    fbb_.AddElement<int32_t>(Vehicle::VT_SESSIONPOS, sessionPos, 0);
  }
  void add_color(const Color *color) {
    fbb_.AddStruct(Vehicle::VT_COLOR, color);
  }
  void add_normalisedTrackPos(float normalisedTrackPos) {
    fbb_.AddElement<float>(Vehicle::VT_NORMALISEDTRACKPOS, normalisedTrackPos, 0.0f);
  }
  explicit VehicleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VehicleBuilder &operator=(const VehicleBuilder &);
  flatbuffers::Offset<Vehicle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Vehicle>(end);
    return o;
  }
};

inline flatbuffers::Offset<Vehicle> CreateVehicle(
    flatbuffers::FlatBufferBuilder &_fbb,
    VehicleState state = VehicleState_Unknown,
    float posX = 0.0f,
    float posY = 0.0f,
    float posZ = 0.0f,
    float yaw = 0.0f,
    int32_t sessionPos = 0,
    const Color *color = 0,
    float normalisedTrackPos = 0.0f) {
  VehicleBuilder builder_(_fbb);
  builder_.add_normalisedTrackPos(normalisedTrackPos);
  builder_.add_color(color);
  builder_.add_sessionPos(sessionPos);
  builder_.add_yaw(yaw);
  builder_.add_posZ(posZ);
  builder_.add_posY(posY);
  builder_.add_posX(posX);
  builder_.add_state(state);
  return builder_.Finish();
}

/// Session data
struct Session FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TOTALTIME = 4,
    VT_TIMELEFT = 6,
    VT_TOTALLAPS = 8,
    VT_VEHICLES = 10
  };
  int32_t totalTime() const {
    return GetField<int32_t>(VT_TOTALTIME, 0);
  }
  int32_t timeLeft() const {
    return GetField<int32_t>(VT_TIMELEFT, 0);
  }
  int32_t totalLaps() const {
    return GetField<int32_t>(VT_TOTALLAPS, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Vehicle>> *vehicles() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Vehicle>> *>(VT_VEHICLES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TOTALTIME) &&
           VerifyField<int32_t>(verifier, VT_TIMELEFT) &&
           VerifyField<int32_t>(verifier, VT_TOTALLAPS) &&
           VerifyOffset(verifier, VT_VEHICLES) &&
           verifier.VerifyVector(vehicles()) &&
           verifier.VerifyVectorOfTables(vehicles()) &&
           verifier.EndTable();
  }
};

struct SessionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_totalTime(int32_t totalTime) {
    fbb_.AddElement<int32_t>(Session::VT_TOTALTIME, totalTime, 0);
  }
  void add_timeLeft(int32_t timeLeft) {
    fbb_.AddElement<int32_t>(Session::VT_TIMELEFT, timeLeft, 0);
  }
  void add_totalLaps(int32_t totalLaps) {
    fbb_.AddElement<int32_t>(Session::VT_TOTALLAPS, totalLaps, 0);
  }
  void add_vehicles(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Vehicle>>> vehicles) {
    fbb_.AddOffset(Session::VT_VEHICLES, vehicles);
  }
  explicit SessionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SessionBuilder &operator=(const SessionBuilder &);
  flatbuffers::Offset<Session> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Session>(end);
    return o;
  }
};

inline flatbuffers::Offset<Session> CreateSession(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t totalTime = 0,
    int32_t timeLeft = 0,
    int32_t totalLaps = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Vehicle>>> vehicles = 0) {
  SessionBuilder builder_(_fbb);
  builder_.add_vehicles(vehicles);
  builder_.add_totalLaps(totalLaps);
  builder_.add_timeLeft(timeLeft);
  builder_.add_totalTime(totalTime);
  return builder_.Finish();
}

inline flatbuffers::Offset<Session> CreateSessionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t totalTime = 0,
    int32_t timeLeft = 0,
    int32_t totalLaps = 0,
    const std::vector<flatbuffers::Offset<Vehicle>> *vehicles = nullptr) {
  return KartKraft::CreateSession(
      _fbb,
      totalTime,
      timeLeft,
      totalLaps,
      vehicles ? _fbb.CreateVector<flatbuffers::Offset<Vehicle>>(*vehicles) : 0);
}

/// Root object from which all data can be extracted. You must check if motion, dash etc exist before using as not every packet will include all data.
struct Frame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIMESTAMP = 4,
    VT_MOTION = 6,
    VT_DASH = 8,
    VT_SESSION = 10
  };
  float timestamp() const {
    return GetField<float>(VT_TIMESTAMP, 0.0f);
  }
  const Motion *motion() const {
    return GetPointer<const Motion *>(VT_MOTION);
  }
  const Dashboard *dash() const {
    return GetPointer<const Dashboard *>(VT_DASH);
  }
  const Session *session() const {
    return GetPointer<const Session *>(VT_SESSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_TIMESTAMP) &&
           VerifyOffset(verifier, VT_MOTION) &&
           verifier.VerifyTable(motion()) &&
           VerifyOffset(verifier, VT_DASH) &&
           verifier.VerifyTable(dash()) &&
           VerifyOffset(verifier, VT_SESSION) &&
           verifier.VerifyTable(session()) &&
           verifier.EndTable();
  }
};

struct FrameBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(float timestamp) {
    fbb_.AddElement<float>(Frame::VT_TIMESTAMP, timestamp, 0.0f);
  }
  void add_motion(flatbuffers::Offset<Motion> motion) {
    fbb_.AddOffset(Frame::VT_MOTION, motion);
  }
  void add_dash(flatbuffers::Offset<Dashboard> dash) {
    fbb_.AddOffset(Frame::VT_DASH, dash);
  }
  void add_session(flatbuffers::Offset<Session> session) {
    fbb_.AddOffset(Frame::VT_SESSION, session);
  }
  explicit FrameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FrameBuilder &operator=(const FrameBuilder &);
  flatbuffers::Offset<Frame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Frame>(end);
    return o;
  }
};

inline flatbuffers::Offset<Frame> CreateFrame(
    flatbuffers::FlatBufferBuilder &_fbb,
    float timestamp = 0.0f,
    flatbuffers::Offset<Motion> motion = 0,
    flatbuffers::Offset<Dashboard> dash = 0,
    flatbuffers::Offset<Session> session = 0) {
  FrameBuilder builder_(_fbb);
  builder_.add_session(session);
  builder_.add_dash(dash);
  builder_.add_motion(motion);
  builder_.add_timestamp(timestamp);
  return builder_.Finish();
}

inline const KartKraft::Frame *GetFrame(const void *buf) {
  return flatbuffers::GetRoot<KartKraft::Frame>(buf);
}

inline const KartKraft::Frame *GetSizePrefixedFrame(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<KartKraft::Frame>(buf);
}

inline bool VerifyFrameBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<KartKraft::Frame>(nullptr);
}

inline bool VerifySizePrefixedFrameBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<KartKraft::Frame>(nullptr);
}

inline void FinishFrameBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<KartKraft::Frame> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedFrameBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<KartKraft::Frame> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace KartKraft

#endif  // FLATBUFFERS_GENERATED_FRAME_KARTKRAFT_H_
